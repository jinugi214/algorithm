import sys

# 변경될 때마다 반전이 필요한 횟수
arr = [
    [0, 4, 3, 3, 4, 3, 2, 3, 1, 2],
    [4, 0, 5, 3, 2, 5, 6, 1, 5, 4],
    [3, 5, 0, 2, 5, 4, 3, 4, 2, 3],
    [3, 3, 2, 0, 3, 2, 3, 2, 2, 1],
    [4, 2, 5, 3, 0, 3, 4, 3, 3, 2],
    [3, 5, 4, 2, 3, 0, 1, 4, 2, 1],
    [2, 6, 3, 3, 4, 1, 0, 5, 1, 2],
    [3, 1, 4, 2, 3, 4, 5, 0, 4, 3],
    [1, 5, 2, 2, 3, 2, 1, 4, 0, 1],
    [2, 4, 3, 1, 2, 1, 2, 3, 1, 0]
]

# dfs를 통해 모든 경우의 수 탐색
# 자리수, 10^(자리수), 현재까지의 수, 반전시킨 횟수
def solve(idx, temp, cur, cnt):
    global result
    # 최대 반전수를 넘거나, 현재가 최대층을 넘으면 return
    if cnt > P or cur > N:
        return
    if idx == K: # 디스플레이 최대 자리수이면
        if cur != 0: # 한번이라도 반전시켰다면
            result += 1 # 경우의 수 1 추가
        return
    for i in range(10):
        # 자리수 + 1 추가, 다음 자리수, 다음 수, 배열을 통한 반전횟수 추가
        solve(idx+1, temp*10, i*temp+cur, cnt+arr[X//temp % 10][i])

# N 최대층
# K 디스플레이 최대 자리수
# P 최대 반전시킬 개수
# X 멈춰있는 층

N, K, P, X = map(int, sys.stdin.readline().split())
result = 0
solve(0, 1, 0, 0)
print(result - 1) # 멈춰있는 층 제외